#!/usr/bin/env kotlin

import java.math.BigInteger

/**
 * Even Fibonacci numbers.
 *
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
 * find the sum of the even-valued terms.
 */
fun eval(): BigInteger {
  return fibValueLimit(limit = 4_000_000.toBigInteger())
    .filter { it.mod(2.toBigInteger()) == BigInteger.ZERO }
    .reduce { acc, bigInteger -> acc + bigInteger }
}

/**
 * Fibonacci sequence via memoization.
 */
fun fib(n: Int): Array<BigInteger> {
  // index   : 0, 1, 2, 3, 4, 5, 6,  7,  8,...
  // fib seq : 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

  val size: Int = n + 1
  val numbers = Array<BigInteger>(size) { BigInteger.ZERO }

  repeat(size) {
    when (it) {
      0 -> numbers[it] = BigInteger.ZERO
      1 -> numbers[it] = BigInteger.ONE
      else -> numbers[it] = numbers[it - 1] + numbers[it - 2]
    }
  }

  return numbers
}

/**
 * Fibonacci sequence via memoization, but with value limit.
 */
fun fibValueLimit(limit: BigInteger): List<BigInteger> {
  // index   : 0, 1, 2, 3, 4, 5, 6,  7,  8,...
  // fib seq : 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

  val numbers = mutableListOf<BigInteger>()
  var n = 0

  while (true) {
    val sum: BigInteger = when (n) {
      0 -> BigInteger.ZERO
      1 -> BigInteger.ONE
      else -> numbers[n - 1] + numbers[n - 2]
    }

    if (sum > limit) {
      break
    }

    numbers.add(sum)
    n++
  }

  return numbers
}

println("Even Fibonacci numbers:")
println(eval()) // 4613732
